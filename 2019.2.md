## 2
  * UPDATE T1 SET T1.NAME = 'KEVIN' FORM T1 INNER JOIN T2 ON T1.ID = T2.ID
  * SelectMany
    ```
      var query = from file in Directory.GetFiles()
                  from line in ReadLines(file)
                  let entry = new LogEntry(line)
                  where entry.Type == EntryType.Error
                  select entry;
    ```
   *  dynamic
   ```
    dynamic values = JsonConvert.DeserializeObject<dynamic>(e.Data);
    slot.BirthDate = values["BirthDate"];
    slot.Email = values["Email"];
    slot.Name = values["Name"];
   ```
##5
  * 策略模式
  1. 商场打折，分别封装打折方法
  * Reflect
  ```
  Assembly.Load("Zion.Business").CreateInstance($"Zion.Business.Export.Impl.{exporterName}", false);
  ```
  * Singleton Pattern
  ```
  public static Singleton SingleInstance
    {
      get
      {
        if (singleInstance == null)
        {
          lock (lockObject)
          {
            if (singleInstance == null)
            {
              singleInstance = new Singleton();
            }

          }
        }
        return singleInstance;
      }
    }
  ```
  
  ## 7
  * 状态码模式
  * 适配器模式
  1. 对象适配模式 推荐使用对象模式
  2. 类适配模式  需要多重继承
  * 继承 vs 组合
    1. is-a关系用继承表达，has-a关系用组合表达。继承体现的是一种专门化的概念而组合则是一种组装的概念。可以通过实现接口与组合的方式来达到相同的目的。设计模式中的策略模式可以很好的说明这一点，采用接口与组合的方式比采用继承的方式具有更好的可扩展性。
    2. 除非用到向上转换，不然优先考虑组合。
    
 ## 8
 1. Value Object
    * 值对象可以对某些简单业务概念建模
    * 值对象没有标识。值对象比实体简单得多，不需要跟踪变化，所以它没有标识。
    * 值对象是不可变的。这是值对象的核心特征，后面将详述。
    * 值对象的相等性比较是通过各个属性值的比较来完成的。
    * 由于值对象代表一个概念整体，所以只能进行整体替换，而不是修改值对象的某个属性。
 2. Entity Object
    * 实体拥有标识，而值对象没有
    * 相等性测试方式不同。实体根据标识判等，而值对象根据内部所有属性值判等。
    * 实体允许变化，值对象不允许变化。
    * 持久化的映射方式不同。实体采用单表继承、类表继承和具体表继承来映射类层次结构，而值对象使用嵌入值或序列化大对象方式映射。
